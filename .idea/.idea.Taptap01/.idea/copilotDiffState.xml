<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FSM/FinateStateMachine.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FSM/FinateStateMachine.cs" />
              <option name="originalContent" value="using System;&#10;using UnityEngine;&#10;using System.Collections.Generic;&#10;using Sirenix.OdinInspector;&#10;&#10;namespace FSM&#10;{&#10;    public class FinateStateMachine : MonoBehaviour&#10;    {&#10;        // 信号类型枚举，格式为 [FromState]2[ToState]&#10;        public enum SignalType&#10;        {&#10;            Idle2Move,      // 从Idle状态转换到Move状态&#10;            Move2Idle,      // 从Move状态转换到Idle状态&#10;            Any2Hurt,       // 从任意状态转换到Hurt状态&#10;            Any2Dead,       // 从任意状态转换到Dead状态&#10;            Idle2Attack,    // 从Idle状态转换到Attack状态&#10;            Move2Attack,    // 从Move状态转换到Attack状态&#10;            Attack2Idle,    // 从Attack状态转换到Idle状态&#10;            Hurt2Idle       // 从Hurt状态转换到Idle状态&#10;            // 可以根据需要继续扩展&#10;        }&#10;        [ShowInInspector,ReadOnly]&#10;        private State currentState;&#10;        private Dictionary&lt;StateType, State&gt; stateDict;&#10;        private Dictionary&lt;SignalType, System.Action&gt; signalHandlers;&#10;        private SignalType? pendingSignal = null; // 当前待处理的信号&#10;        private bool signalProcessedThisFrame = false; // 标记信号是否在本帧被处理&#10;        private bool blocked = false; // 是否阻止状态转换&#10;&#10;        private void Awake()&#10;        {&#10;            // 初始化状态字典&#10;            stateDict = new Dictionary&lt;StateType, State&gt;&#10;            {&#10;                { StateType.Idle, new IdleState(this) },&#10;                { StateType.Move, new MoveState(this) },&#10;                { StateType.Hurt, new HurtState(this) },&#10;                { StateType.Dead, new DeadState(this) },&#10;                { StateType.Attack, new AttackState(this) }&#10;            };&#10;&#10;            // 初始化信号处理器字典&#10;            signalHandlers = new Dictionary&lt;SignalType, System.Action&gt;&#10;            {&#10;                { SignalType.Idle2Move, () =&gt; HandleTransitionSignal(StateType.Idle, StateType.Move) },&#10;                { SignalType.Move2Idle, () =&gt; HandleTransitionSignal(StateType.Move, StateType.Idle) },&#10;                { SignalType.Any2Hurt, () =&gt; HandleTransitionSignal(null, StateType.Hurt) },&#10;                { SignalType.Any2Dead, () =&gt; HandleTransitionSignal(null, StateType.Dead) },&#10;                { SignalType.Idle2Attack, () =&gt; HandleTransitionSignal(StateType.Idle, StateType.Attack) },&#10;                { SignalType.Move2Attack, () =&gt; HandleTransitionSignal(StateType.Move, StateType.Attack) },&#10;                { SignalType.Attack2Idle, () =&gt; HandleTransitionSignal(StateType.Attack, StateType.Idle) },&#10;                { SignalType.Hurt2Idle, () =&gt; HandleTransitionSignal(StateType.Hurt, StateType.Idle) }&#10;            };&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            ChangeState(StateType.Idle);&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            // 清理当前状态&#10;            if (currentState != null)&#10;            {&#10;                &#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// 发射状态转换信号&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;signal&quot;&gt;信号类型&lt;/param&gt;&#10;        public void EmitSignal(SignalType signal)&#10;        {&#10;            pendingSignal = signal;&#10;            signalProcessedThisFrame = false;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// 处理状态转换信号&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;requiredFromState&quot;&gt;需要的起始状态类型，null表示任意状态&lt;/param&gt;&#10;        /// &lt;param name=&quot;targetState&quot;&gt;目标状态类型&lt;/param&gt;&#10;        private void HandleTransitionSignal(StateType? requiredFromState, StateType targetState)&#10;        {&#10;            // 检查是否阻止状态转换&#10;            if (blocked)&#10;            {&#10;                Debug.LogWarning($&quot;State transition blocked. Cannot transition to {targetState}.&quot;);&#10;                return;&#10;            }&#10;            // 检查当前状态是否符合要求&#10;            bool canTransition = requiredFromState == null || &#10;                               (currentState != null &amp;&amp; currentState.GetStateType() == requiredFromState.Value);&#10;&#10;            if (canTransition)&#10;            {&#10;                // 符合条件，执行状态转换&#10;                ChangeState(targetState);&#10;                signalProcessedThisFrame = true;&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning($&quot;Cannot transition from {currentState?.GetStateType()} to {targetState}. &quot; +&#10;                               $&quot;Required from state: {requiredFromState}&quot;);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// 根据信号类型获取起始状态和目标状态&#10;        /// &lt;/summary&gt;&#10;        private (StateType? fromState, StateType toState) ParseSignal(SignalType signal)&#10;        {&#10;            string signalStr = signal.ToString();&#10;            &#10;            if (signalStr.StartsWith(&quot;Any2&quot;))&#10;            {&#10;                string toStateStr = signalStr.Substring(4);&#10;                if (Enum.TryParse(toStateStr, out StateType toState))&#10;                {&#10;                    return (null, toState);&#10;                }&#10;            }&#10;            else if (signalStr.Contains(&quot;2&quot;))&#10;            {&#10;                string[] parts = signalStr.Split(new string[] { &quot;2&quot; }, StringSplitOptions.RemoveEmptyEntries);&#10;                if (parts.Length == 2)&#10;                {&#10;                    if (Enum.TryParse(parts[0], out StateType fromState) &amp;&amp; &#10;                        Enum.TryParse(parts[1], out StateType toState))&#10;                    {&#10;                        return (fromState, toState);&#10;                    }&#10;                }&#10;            }&#10;&#10;            Debug.LogError($&quot;Invalid signal format: {signal}&quot;);&#10;            return (null, StateType.Idle); // 默认返回Idle状态&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// 动态注册信号处理器&#10;        /// &lt;/summary&gt;&#10;        public void RegisterSignalHandler(SignalType signal, System.Action handler)&#10;        {&#10;            signalHandlers[signal] = handler;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// 动态创建并注册信号处理器&#10;        /// &lt;/summary&gt;&#10;        public void RegisterTransitionSignal(SignalType signal, StateType? fromState, StateType toState)&#10;        {&#10;            signalHandlers[signal] = () =&gt; HandleTransitionSignal(fromState, toState);&#10;        }&#10;&#10;        public void ChangeState(State newState)&#10;        {&#10;            if (currentState != null)&#10;                currentState.Exit();&#10;            currentState = newState;&#10;            if (currentState != null)&#10;                currentState.Enter();&#10;        }&#10;&#10;        public void ChangeState(StateType type)&#10;        {&#10;            if (stateDict.TryGetValue(type, out var newState))&#10;            {&#10;                ChangeState(newState);&#10;            }&#10;        }&#10;&#10;        public void Update()&#10;        {&#10;            // 重置信号处理标志&#10;            signalProcessedThisFrame = false;&#10;&#10;            // 检查是否有待处理的信号&#10;            if (pendingSignal.HasValue &amp;&amp; signalHandlers.ContainsKey(pendingSignal.Value))&#10;            {&#10;                // 调用对应的信号处理函数&#10;                signalHandlers[pendingSignal.Value]?.Invoke();&#10;                &#10;                // 如果信号被处理，清除待处理信号&#10;                if (signalProcessedThisFrame)&#10;                {&#10;                    pendingSignal = null;&#10;                }&#10;            }&#10;&#10;            // 执行当前状态的逻辑&#10;            if (currentState != null)&#10;                currentState.Execute();&#10;        }&#10;&#10;        public State GetCurrentState()&#10;        {&#10;            return currentState;&#10;        }&#10;&#10;        public State GetState(StateType type)&#10;        {&#10;            stateDict.TryGetValue(type, out var state);&#10;            return state;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// 检查是否可以发射某个信号（检查当前状态是否符合起始状态要求）&#10;        /// &lt;/summary&gt;&#10;        public bool CanEmitSignal(SignalType signal)&#10;        {&#10;            if (signalHandlers.TryGetValue(signal, out var handler))&#10;            {&#10;                var (fromState, _) = ParseSignal(signal);&#10;                return fromState == null || (currentState != null &amp;&amp; currentState.GetStateType() == fromState.Value);&#10;            }&#10;            return false;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// 获取当前待处理的信号&#10;        /// &lt;/summary&gt;&#10;        public SignalType? GetPendingSignal()&#10;        {&#10;            return pendingSignal;&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using UnityEngine;&#10;using System.Collections.Generic;&#10;using Sirenix.OdinInspector;&#10;&#10;namespace FSM&#10;{&#10;    public class FinateStateMachine : MonoBehaviour&#10;    {&#10;        // 信号类型枚举，格式为 [FromState]2[ToState]&#10;        public enum SignalType&#10;        {&#10;            Idle2Move,      // 从Idle状态转换到Move状态&#10;            Move2Idle,      // 从Move状态转换到Idle状态&#10;            Any2Hurt,       // 从任意状态转换到Hurt状态&#10;            Any2Dead,       // 从任意状态转换到Dead状态&#10;            Idle2Attack,    // 从Idle状态转换到Attack状态&#10;            Move2Attack,    // 从Move状态转换到Attack状态&#10;            Attack2Idle,    // 从Attack状态转换到Idle状态&#10;            Hurt2Idle       // 从Hurt状态转换到Idle状态&#10;            // 可以根据需要继续扩展&#10;        }&#10;        [ShowInInspector,ReadOnly]&#10;        private State currentState;&#10;        private Dictionary&lt;StateType, State&gt; stateDict;&#10;        private Dictionary&lt;SignalType, System.Action&gt; signalHandlers;&#10;        private SignalType? pendingSignal = null; // 当前待处理的信号&#10;        private bool signalProcessedThisFrame = false; // 标记信号是否在本帧被处理&#10;        private bool blocked = false; // 是否阻止状态转换&#10;&#10;        private void Awake()&#10;        {&#10;            // 初始化状态字典&#10;            stateDict = new Dictionary&lt;StateType, State&gt;&#10;            {&#10;                { StateType.Idle, new IdleState(this) },&#10;                { StateType.Move, new MoveState(this) },&#10;                { StateType.Hurt, new HurtState(this) },&#10;                { StateType.Dead, new DeadState(this) },&#10;                { StateType.Attack, new AttackState(this) }&#10;            };&#10;&#10;            // 初始化信号处理器字典&#10;            signalHandlers = new Dictionary&lt;SignalType, System.Action&gt;&#10;            {&#10;                { SignalType.Idle2Move, () =&gt; HandleTransitionSignal(StateType.Idle, StateType.Move) },&#10;                { SignalType.Move2Idle, () =&gt; HandleTransitionSignal(StateType.Move, StateType.Idle) },&#10;                { SignalType.Any2Hurt, () =&gt; HandleTransitionSignal(null, StateType.Hurt) },&#10;                { SignalType.Any2Dead, () =&gt; HandleTransitionSignal(null, StateType.Dead) },&#10;                { SignalType.Idle2Attack, () =&gt; HandleTransitionSignal(StateType.Idle, StateType.Attack) },&#10;                { SignalType.Move2Attack, () =&gt; HandleTransitionSignal(StateType.Move, StateType.Attack) },&#10;                { SignalType.Attack2Idle, () =&gt; HandleTransitionSignal(StateType.Attack, StateType.Idle) },&#10;                { SignalType.Hurt2Idle, () =&gt; HandleTransitionSignal(StateType.Hurt, StateType.Idle) }&#10;            };&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            ChangeState(StateType.Idle);&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            // 清理当前状态&#10;            if (currentState != null)&#10;            {&#10;                &#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// 发射状态转换信号&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;signal&quot;&gt;信号类型&lt;/param&gt;&#10;        public void EmitSignal(SignalType signal)&#10;        {&#10;            pendingSignal = signal;&#10;            signalProcessedThisFrame = false;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// 处理状态转换信号&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;requiredFromState&quot;&gt;需要的起始状态类型，null表示任意状态&lt;/param&gt;&#10;        /// &lt;param name=&quot;targetState&quot;&gt;目标状态类型&lt;/param&gt;&#10;        private void HandleTransitionSignal(StateType? requiredFromState, StateType targetState)&#10;        {&#10;            // 检查是否阻止状态转换&#10;            if (blocked)&#10;            {&#10;                Debug.LogWarning($&quot;State transition blocked. Cannot transition to {targetState}.&quot;);&#10;                return;&#10;            }&#10;            // 检查当前状态是否符合要求&#10;            bool canTransition = requiredFromState == null || &#10;                               (currentState != null &amp;&amp; currentState.GetStateType() == requiredFromState.Value);&#10;&#10;            if (canTransition)&#10;            {&#10;                // 符合条件，执行状态转换&#10;                ChangeState(targetState);&#10;                signalProcessedThisFrame = true;&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning($&quot;Cannot transition from {currentState?.GetStateType()} to {targetState}. &quot; +&#10;                               $&quot;Required from state: {requiredFromState}&quot;);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// 根据信号类型获取起始状态和目标状态&#10;        /// &lt;/summary&gt;&#10;        private (StateType? fromState, StateType toState) ParseSignal(SignalType signal)&#10;        {&#10;            string signalStr = signal.ToString();&#10;            &#10;            if (signalStr.StartsWith(&quot;Any2&quot;))&#10;            {&#10;                string toStateStr = signalStr.Substring(4);&#10;                if (Enum.TryParse(toStateStr, out StateType toState))&#10;                {&#10;                    return (null, toState);&#10;                }&#10;            }&#10;            else if (signalStr.Contains(&quot;2&quot;))&#10;            {&#10;                string[] parts = signalStr.Split(new string[] { &quot;2&quot; }, StringSplitOptions.RemoveEmptyEntries);&#10;                if (parts.Length == 2)&#10;                {&#10;                    if (Enum.TryParse(parts[0], out StateType fromState) &amp;&amp; &#10;                        Enum.TryParse(parts[1], out StateType toState))&#10;                    {&#10;                        return (fromState, toState);&#10;                    }&#10;                }&#10;            }&#10;&#10;            Debug.LogError($&quot;Invalid signal format: {signal}&quot;);&#10;            return (null, StateType.Idle); // 默认返回Idle状态&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// 动态注册信号处理器&#10;        /// &lt;/summary&gt;&#10;        public void RegisterSignalHandler(SignalType signal, System.Action handler)&#10;        {&#10;            signalHandlers[signal] = handler;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// 动态创建并注册信号处理器&#10;        /// &lt;/summary&gt;&#10;        public void RegisterTransitionSignal(SignalType signal, StateType? fromState, StateType toState)&#10;        {&#10;            signalHandlers[signal] = () =&gt; HandleTransitionSignal(fromState, toState);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// 设置是否阻止状态转换&#10;        /// &lt;/summary&gt;&#10;        public void SetBlocked(bool value)&#10;        {&#10;            blocked = value;&#10;        }&#10;&#10;        public void ChangeState(State newState)&#10;        {&#10;            if (blocked)&#10;            {&#10;                Debug.LogWarning($&quot;State transition blocked. Cannot change to {newState?.GetStateType()}.&quot;);&#10;                return;&#10;            }&#10;            if (currentState != null)&#10;                currentState.Exit();&#10;            currentState = newState;&#10;            if (currentState != null)&#10;                currentState.Enter();&#10;        }&#10;&#10;        public void ChangeState(StateType type)&#10;        {&#10;            if (blocked)&#10;            {&#10;                Debug.LogWarning($&quot;State transition blocked. Cannot change to {type}.&quot;);&#10;                return;&#10;            }&#10;            if (stateDict.TryGetValue(type, out var newState))&#10;            {&#10;                ChangeState(newState);&#10;            }&#10;        }&#10;&#10;        public void Update()&#10;        {&#10;            // 重置信号处理标志&#10;            signalProcessedThisFrame = false;&#10;&#10;            // 检查是否有待处理的信号&#10;            if (pendingSignal.HasValue &amp;&amp; signalHandlers.ContainsKey(pendingSignal.Value))&#10;            {&#10;                // 调用对应的信号处理函数&#10;                signalHandlers[pendingSignal.Value]?.Invoke();&#10;                &#10;                // 如果信号被处理，清除待处理信号&#10;                if (signalProcessedThisFrame)&#10;                {&#10;                    pendingSignal = null;&#10;                }&#10;            }&#10;&#10;            // 执行当前状态的逻辑&#10;            if (currentState != null)&#10;                currentState.Execute();&#10;        }&#10;&#10;        public State GetCurrentState()&#10;        {&#10;            return currentState;&#10;        }&#10;&#10;        public State GetState(StateType type)&#10;        {&#10;            stateDict.TryGetValue(type, out var state);&#10;            return state;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// 检查是否可以发射某个信号（检查当前状态是否符合起始状态要求）&#10;        /// &lt;/summary&gt;&#10;        public bool CanEmitSignal(SignalType signal)&#10;        {&#10;            if (signalHandlers.TryGetValue(signal, out var handler))&#10;            {&#10;                var (fromState, _) = ParseSignal(signal);&#10;                return fromState == null || (currentState != null &amp;&amp; currentState.GetStateType() == fromState.Value);&#10;            }&#10;            return false;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// 获取当前待处理的信号&#10;        /// &lt;/summary&gt;&#10;        public SignalType? GetPendingSignal()&#10;        {&#10;            return pendingSignal;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FSM/State.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FSM/State.cs" />
              <option name="originalContent" value="namespace FSM&#10;{&#10;    public enum StateType&#10;    {&#10;        Idle,&#10;        Move,&#10;        Hurt,&#10;        Dead,&#10;        Attack&#10;    }&#10;&#10;    public abstract class State&#10;    {&#10;        public StateType Type { get; protected set; }&#10;        protected FinateStateMachine fsm;&#10;&#10;        public State(FinateStateMachine fsm)&#10;        {&#10;            this.fsm = fsm;&#10;        }&#10;        public abstract void Enter();&#10;        public abstract void Execute();&#10;        public abstract void Exit();&#10;        public StateType GetStateType() =&gt; Type;&#10;    }&#10;&#10;    public class IdleState : State&#10;    {&#10;        public IdleState(FinateStateMachine fsm) : base(fsm)&#10;        {&#10;            Type = StateType.Idle;&#10;        }&#10;        public override void Enter() { /* 待机状态进入逻辑 */ }&#10;        public override void Execute() { /* 待机状态执行逻辑 */ }&#10;        public override void Exit() { /* 待机状态退出逻辑 */ }&#10;    }&#10;&#10;    public class MoveState : State&#10;    {&#10;        public MoveState(FinateStateMachine fsm) : base(fsm)&#10;        {&#10;            Type = StateType.Move;&#10;        }&#10;        public override void Enter() { /* 移动状态进入逻辑 */ }&#10;        public override void Execute() { /* 移动状态执行逻辑 */ }&#10;        public override void Exit() { /* 移动状态退出逻辑 */ }&#10;    }&#10;&#10;    public class HurtState : State&#10;    {&#10;        public HurtState(FinateStateMachine fsm) : base(fsm)&#10;        {&#10;            Type = StateType.Hurt;&#10;        }&#10;        public override void Enter() { /* 受伤状态进入逻辑 */ }&#10;        public override void Execute() { /* 受伤状态执行逻辑 */ }&#10;        public override void Exit() { /* 受伤状态退出逻辑 */ }&#10;    }&#10;&#10;    public class DeadState : State&#10;    {&#10;        public DeadState(FinateStateMachine fsm) : base(fsm)&#10;        {&#10;            Type = StateType.Dead;&#10;        }&#10;        public override void Enter() { /* 死亡状态进入逻辑 */ }&#10;        public override void Execute() { /* 死亡状态执行逻辑 */ }&#10;        public override void Exit() { /* 死亡状态退出逻辑 */ }&#10;    }&#10;&#10;    public class AttackState : State&#10;    {&#10;        public AttackState(FinateStateMachine fsm) : base(fsm)&#10;        {&#10;            Type = StateType.Attack;&#10;        }&#10;        public override void Enter() { /* 攻击状态进入逻辑 */ }&#10;        public override void Execute() { /* 攻击状态执行逻辑 */ }&#10;        public override void Exit() { /* 攻击状态退出逻辑 */ }&#10;    }&#10;}" />
              <option name="updatedContent" value="namespace FSM&#10;{&#10;    public enum StateType&#10;    {&#10;        Idle,&#10;        Move,&#10;        Hurt,&#10;        Dead,&#10;        Attack&#10;    }&#10;&#10;    public abstract class State&#10;    {&#10;        public StateType Type { get; protected set; }&#10;        protected FinateStateMachine fsm;&#10;&#10;        public State(FinateStateMachine fsm)&#10;        {&#10;            this.fsm = fsm;&#10;        }&#10;        public abstract void Enter();&#10;        public abstract void Execute();&#10;        public abstract void Exit();&#10;        public StateType GetStateType() =&gt; Type;&#10;    }&#10;&#10;    public class IdleState : State&#10;    {&#10;        public IdleState(FinateStateMachine fsm) : base(fsm)&#10;        {&#10;            Type = StateType.Idle;&#10;        }&#10;        public override void Enter()&#10;        {&#10;            UnityEngine.Debug.Log(&quot;IdleState Enter&quot;);&#10;            /* 待机状态进入逻辑 */&#10;        }&#10;        public override void Execute()&#10;        {&#10;            UnityEngine.Debug.Log(&quot;IdleState Execute&quot;);&#10;            /* 待机状态执行逻辑 */&#10;        }&#10;        public override void Exit()&#10;        {&#10;            UnityEngine.Debug.Log(&quot;IdleState Exit&quot;);&#10;            /* 待机状态退出逻辑 */&#10;        }&#10;    }&#10;&#10;    public class MoveState : State&#10;    {&#10;        public MoveState(FinateStateMachine fsm) : base(fsm)&#10;        {&#10;            Type = StateType.Move;&#10;        }&#10;        public override void Enter()&#10;        {&#10;            UnityEngine.Debug.Log(&quot;MoveState Enter&quot;);&#10;            /* 移动状态进入逻辑 */&#10;        }&#10;        public override void Execute()&#10;        {&#10;            UnityEngine.Debug.Log(&quot;MoveState Execute&quot;);&#10;            /* 移动状态执行逻辑 */&#10;        }&#10;        public override void Exit()&#10;        {&#10;            UnityEngine.Debug.Log(&quot;MoveState Exit&quot;);&#10;            /* 移动状态退出逻辑 */&#10;        }&#10;    }&#10;&#10;    public class HurtState : State&#10;    {&#10;        public HurtState(FinateStateMachine fsm) : base(fsm)&#10;        {&#10;            Type = StateType.Hurt;&#10;        }&#10;        public override void Enter()&#10;        {&#10;            UnityEngine.Debug.Log(&quot;HurtState Enter&quot;);&#10;            /* 受伤状态进入逻辑 */&#10;        }&#10;        public override void Execute()&#10;        {&#10;            UnityEngine.Debug.Log(&quot;HurtState Execute&quot;);&#10;            /* 受伤状态执行逻辑 */&#10;        }&#10;        public override void Exit()&#10;        {&#10;            UnityEngine.Debug.Log(&quot;HurtState Exit&quot;);&#10;            /* 受伤状态退出逻辑 */&#10;        }&#10;    }&#10;&#10;    public class DeadState : State&#10;    {&#10;        public DeadState(FinateStateMachine fsm) : base(fsm)&#10;        {&#10;            Type = StateType.Dead;&#10;        }&#10;        public override void Enter()&#10;        {&#10;            UnityEngine.Debug.Log(&quot;DeadState Enter&quot;);&#10;            /* 死亡状态进入逻辑 */&#10;        }&#10;        public override void Execute()&#10;        {&#10;            UnityEngine.Debug.Log(&quot;DeadState Execute&quot;);&#10;            /* 死亡状态执行逻辑 */&#10;        }&#10;        public override void Exit()&#10;        {&#10;            UnityEngine.Debug.Log(&quot;DeadState Exit&quot;);&#10;            /* 死亡状态退出逻辑 */&#10;        }&#10;    }&#10;&#10;    public class AttackState : State&#10;    {&#10;        public AttackState(FinateStateMachine fsm) : base(fsm)&#10;        {&#10;            Type = StateType.Attack;&#10;        }&#10;        public override void Enter()&#10;        {&#10;            UnityEngine.Debug.Log(&quot;AttackState Enter&quot;);&#10;            /* 攻击状态进入逻辑 */&#10;        }&#10;        public override void Execute()&#10;        {&#10;            UnityEngine.Debug.Log(&quot;AttackState Execute&quot;);&#10;            /* 攻击状态执行逻辑 */&#10;        }&#10;        public override void Exit()&#10;        {&#10;            UnityEngine.Debug.Log(&quot;AttackState Exit&quot;);&#10;            /* 攻击状态退出逻辑 */&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>